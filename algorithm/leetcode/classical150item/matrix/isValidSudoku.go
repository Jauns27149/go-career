/*
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
输入：board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

注意：
1. 一个有效的数独（部分已被填充）不一定是可解的。
2. 只需要根据以上规则，验证已经填入的数字是否有效即可。
3. 空白格用 '.' 表示。
*/

package main

import "fmt"

type isValidSudokuExample struct {
	board  string
	result bool
}

func main() {
	s := []isValidSudokuExample{
		{"[" +
			"[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]," +
			"[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]," +
			"[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]," +
			"[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]," +
			"[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]," +
			"[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]," +
			"[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]," +
			"[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]," +
			"[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]", false},
		{"[" +
			"[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]," +
			"[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]," +
			"[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]," +
			"[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]," +
			"[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]," +
			"[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]," +
			"[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]," +
			"[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]," +
			"[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]", true},
	}
	for _, v := range s {
		a := isValidSudoku(changeSudoku(v.board))
		fmt.Printf("%v\n%v\n---\n", a, v.result)
	}
}

func changeSudoku(board string) [][]byte {
	n := len(board)
	r := [9][]byte{}
	for i, c := 3, 0; i < n; i, c = i+4, c+1 {
		r[c/9] = append(r[c/9], board[i])
		if (c+1)%9 == 0 {
			i = i + 2
		}
	}
	return r[:]
}

/*
1. 遍历
2. 归位
3. 核对
*/
func isValidSudoku(board [][]byte) bool {
	rc := [9]int{}    // 单行计数数组
	vc := [9][9]int{} // 全列计数数组
	cc := [3][9]int{} // 横向一组3个方格计算数组
	for i, row := range board {
		for ii, v := range row {
			if v != '.' {
				v = v - '0' - 1 // 矩阵值作为数组下标，其出现次数作为数组的值
				rc[v]++
				vc[ii][v]++
				cc[ii/3][v]++
			}

			// 判断方格是否符合条件
			if (i+1)%3 == 0 && (ii+1)%3 == 0 {
				for _, c := range cc[(ii)/3] {
					if c > 1 {
						println("方形9格不符合：", i, ii)
						return false
					}
				}
				cc[(ii)/3] = [9]int{}
			}

			// 判断纵向是否符合条件
			if i == 8 {
				for _, c := range vc[ii] {
					if c > 1 {
						println("纵向不符合")
						return false
					}
				}
			}
		}

		// 判断横向是否符合条件
		for _, c := range rc {
			if c > 1 {
				println("横向不符合")
				return false
			}
		}
		rc = [9]int{}
	}
	return true
}
